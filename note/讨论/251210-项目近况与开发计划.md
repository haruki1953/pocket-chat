## 项目近况
pocket-together 目前处于暂停开发的状态，现在正在进行 pocket-chat 的开发，待 pocket-chat 完善后会将其内容整理并加入至 pocket-together

开发时需拉取 pocket-chat 的全部分支，基于 develop 分支（最新的分支）创建新分支进行开发

pocket-chat 和 pocket-together 的区别主要为没有分房间，且没有导航栏，导航功能由主页右上角的下拉菜单中提供

pocket-chat 目前的功能如项目README所示，其全部页面大致为
```
主页：全局聊天
设置页
登录页

图片页（开发中）
```

### 关于主页右上角的下拉菜单
在 `src\views\chat-home\ChatHome.vue` 中
```vue
      <ChatCol
        :refScrollWarp="appMainElScrollbar?.wrapRef"
        :couldGoBack="false"
        roomId=""
        :chatTitle="websiteName"
      >
        <!-- 插槽 -->
        <template #chatTopBarMoreMenu>
          <!-- 测试批量添加消息，开发时才显示 -->
          <ChatTopBarMoreMenuItem v-if="isDev" @click="testPbSendMessage">
            <!-- <ChatTopBarMoreMenuItem @click="testPbSendMessage"> -->
            <template #icon>
              <RiFlaskLine size="18px"></RiFlaskLine>
            </template>
            <template #text> 测试批量添加消息 </template>
          </ChatTopBarMoreMenuItem>

          <!-- 转到设置，已登录时才显示 -->
          <ChatTopBarMoreMenuItem
            v-if="authStore.isValid"
            @click="$router.push(routerDict.ChatSetting.path)"
          >
            <template #icon>
              <RiSettingsLine size="18px"></RiSettingsLine>
            </template>
            <template #text> {{ i18nStore.t('pageSetting')() }} </template>
          </ChatTopBarMoreMenuItem>
        </template>
      </ChatCol>
```
![](assets/Pasted%20image%2020251210093209.png)

### 关于全局滚动条
大概在10月下旬，就不再使用全局原生的滚动条，转为使用 ElScrollbar 滚动条（在 app.vue 即能看到 ElScrollbar），所以vueuse的 useWindowScroll 就不应再使用了，应使用 useScroll
```ts
import { injectAppMainElScrollbar } from '@/composables'

// inject获取应用主滚动实例
// 类型为 Ref<InstanceType<typeof ElScrollbar> | null>
const appMainElScrollbar = injectAppMainElScrollbar()

// useScroll
useScroll(appMainElScrollbar)
```

可如此操控滚动条滚动
```ts
const appMainElScrollbar = injectAppMainElScrollbar()

appMainElScrollbar.value?.wrapRef?.scrollTo({
  top: 0, // 滚动到顶部
  behavior: 'instant', // 立即滚动，不平滑
})
```

由于 provide-inject 只能在组件上下文中使用，所以在例如 `src\router.ts` 中就不能使用 injectAppMainElScrollbar，应使用 getAppMainElScrollbarWrap
```ts
import { getAppMainElScrollbarWrap } from '@/utils'
// ...
// 新页面回到顶部
router.afterEach((to, from) => {
  // 一些省略的条件判断...
  
  const appMainElScrollbarWrap = getAppMainElScrollbarWrap()

  appMainElScrollbarWrap?.scrollTo({
    top: 0,
    behavior: 'instant',
  })
})
```

### 关于自建的对话框
推荐使用此自建的对话框 `src\components\container\ContainerDialog.vue`
```
其不使用 v-model ，而是使用 dialogVisible 与 dialogCloseFn 来控制其显示

defineProps<{
  /** 控制对话框是否显示的值 */
  dialogVisible: boolean
  /**
   * 对话框的关闭方法，需要传入函数，才能让其点击遮罩时关闭，如
   * () => { dialogVisible.value = false }
   */
  dialogCloseFn: () => void
  // ...
}>

建议搭配 useRouteControlDialog 使用，其用 router 路由参数来控制对话框显示（打开对话框时 router.push 关闭时 router.back），这样的好处是，当对话框处于打开的状态时，浏览器的返回键或手机的返回键能控制对话框关闭，而不是导致整个页面返回
```
使用示例 `src\views\login\components\LoginForm.vue\components\ForgotPasswordDialog.vue`
```vue
<script setup lang="ts">
import { ContainerDialog } from '@/components'
import { useRouteControlDialog } from '@/composables'

const { dialogVisible, dialogOpen, dialogClose } = useRouteControlDialog({
  /** 控制dialog是否显示的query键, 不同的对话框应使用不同的，且要避免与其他query参数冲突 */
  // 简单来讲就是如下图地址栏中显示的字符串
  dialogQueryKey: 'ForgotPasswordDialog',
})

defineExpose({
  dialogOpen,
  dialogClose,
})

// ...
</script>

<template>
  <div class="forgot-password-dialog">
    <ContainerDialog
      :dialogVisible="dialogVisible"
      :dialogCloseFn="dialogClose"
    >
      <div class="flow-root rounded-3xl bg-color-background-soft">
        <div class="m-4">
          <!-- ... -->
        </div>
      </div>
    </ContainerDialog>
  </div>
</template>

<style lang="scss" scoped></style>
```
![](assets/Pasted%20image%2020251210104314.png)

### 关于页面返回时的内容恢复
现象描述，比如聊天页：当在聊天页浏览时，向上滚动了很多，此时又到设置页进行一些操作，然后在设置页操作完毕后，点击返回回到聊天页时，聊天页就能恢复到刚刚浏览的位置。

相关文件
- `src\stores\router-history.ts` 自建路由栈以跟踪路由变化，并做内容恢复所需数据的储存
- `src\components\chat\chat-col\composables\chat-display-dependent-data.ts` 页面返回时的内容恢复 示例

不是每个页面都需要内容恢复功能，内容少的页面就没必要做，如果要在某个新页面做内容恢复功能，实现起来可能有点复杂，可以先不实现，留到最后我来解决

### 关于 api 文件夹
接口之类的封装在 `src\api` ，如
```ts
// src\api\users.ts
import { Collections, pb } from '@/lib'
import { fetchWithTimeoutPreferred } from '@/utils'
//...

/** users集合 getOne */
export const pbUsersGetOneApi = async (id: string) => {
  const pbRes = await pb.collection(Collections.Users).getOne(id, {
    // timeout为5000
    fetch: fetchWithTimeoutPreferred,
  })
  return pbRes
}
```

### 关于 queries 文件夹
useXxxxQuery 之类的，推荐写在，`src\queries` 中的文件中
```ts
// src\queries\profile.ts
import { pbUsersGetOneApi } from '@/api'
import { queryConfig } from '@/config'
import { pb } from '@/lib'
import { queryKeys, queryRetryPbNetworkError } from '@/queries'
import { useAuthStore, usePlaceholderDataProfileStore } from '@/stores'
import { useQuery } from '@tanstack/vue-query'

// 个人信息查询
export const useProfileQuery = () => {
  const authStore = useAuthStore()
  const placeholderDataStore = usePlaceholderDataProfileStore()
  const query = useQuery({
    // 查询依赖，需登录（响应式）
    enabled: computed(() => authStore.isValid && authStore.record?.id != null),
    // 查询键（响应式）
    queryKey: computed(() => queryKeys.profile(authStore.record?.id ?? '')),
    // 查询函数
    queryFn: async () => {
      // 未登录，抛出错误
      if (!pb.authStore.isValid || pb.authStore.record?.id == null) {
        throw new Error(
          '!pb.authStore.isValid || pb.authStore.record?.id == null'
        )
      }
      // pb请求
      const pbRes = await pbUsersGetOneApi(pb.authStore.record.id)
      // console.log(pbRes)
      // 将 pbRes 持久化，以用于 placeholderData
      placeholderDataStore.set(pbRes)
      return pbRes
    },
    // 占位数据
    placeholderData: computed(() => {
      if (placeholderDataStore.data != null) {
        return placeholderDataStore.data
      }
      return undefined
    }),
    // 缓存时间
    gcTime: queryConfig.gcTimeLong,
    staleTime: queryConfig.staleTimeLong,
    // ✅ 在网络错误时重试
    retry: queryRetryPbNetworkError,
  })
  return {
    ...query,
  }
}

```

### 关于 placeholder-data 占位数据
对于某些请求，可将其内容持久化，以达到在下次打开网页时立即显示的效果（显示上次请求的数据，不必等待请求完成就有内容）

可参考上面 useProfileQuery 中的实现
```
src\stores\placeholder-data\profile.ts 中是用于储存数据的 store ，即 usePlaceholderDataProfileStore

在 queryFn 中，得到请求返回的数据后，即可调用 placeholderDataStore.set 将其数据保存

在 placeholderData ，即可设置 placeholderDataStore.data
```

### 关于项目根目录的 project-tools-node 文件夹
其中是一些js工具脚本，用于项目打包之类的一些操作。在 github action 中（`.github\workflows\release.yml`）将使用其内容

### 关于项目中代码封装的方式

#### index.ts
用于 统一导出文件夹中的内容，如
```ts
import ChatTopBar from './ChatTopBar.vue'
export { ChatTopBar }
export * from './chat-message'
```
注意vue文件自己也习惯用 index.ts 来导出，方便管理与重构

#### dependencies.ts
当文件a中需要使用上级文件夹中文件的内容时，就用 dependencies.ts 导入并导出上级中要使用的内容，如
```ts
export * from '../xxx'
```
文件a中只需 
```ts
import { xxxXxxx } from './dependencies' 
```
即文件中避免从上级导入，只有dependencies.ts可以从上级导入并导出，方便管理与重构

#### src/components
需要在多个地方使用的组件会封装在这里，自己习惯手动导入使用，如
```ts
import { ContainerBar, ContainerCol2 } from '@/components'
```

#### src/composables
需要在多个地方使用的组合式函数会封装在这里

#### ./components ./composables 的用处
当一个vue文件写得比较大时，进行重构的办法，这里拿 ExampleFile.vue 举例
```
删除ExampleFile.vue文件

新建如此的文件夹 example-file
example-file/
- components/
  - SomeRefactorComponent.vue
  - index.ts
- composables/
  - some-refactor-composable-func.ts
  - index.ts
- ExampleFile.vue
- index.ts

example-file/ExampleFile.vue 中就可以使用 ./components ./composables 中的内容
example-file/index.ts 中又会导出 example-file/ExampleFile.vue
以此完成重构
```

重构后，需要注意，要在 example-file 的上级目录中的 index.ts 中修改
```
如原先为：
import ExampleFile from './ExampleFile.vue'
export { ExampleFile }
就修改为：
export * from './example-file'
```

关于 composables 即 组合式函数 的意义
```
vue3组合式函数最大用处或设计目的，就是为了便于对vue文件中的逻辑（script）进行封装

组合式函数的参数，即为其需要依赖的一些 响应式数据或配置项，
组合式函数的返回值，即为它所暴露的一些 响应式数据与方法。这些返回值会被组件消费，用来驱动视图或触发交互；或者作为其他的组合式函数的参数。
```


## 开发计划
- 图片、文件发送支持
- 用户列表、在线用户功能
- 用户@功能
- 语音消息

### 图片、文件发送支持
开发中
```
上传图片功能
全部图片、我的图片
搜索图片
图片上传列表、上传进度、上传队列控制
```
![](assets/Pasted%20image%2020251210131101.png)


### 用户列表、在线用户功能

```
新建页面 用户列表页，入口位于主页右上角的下拉菜单
用户列表页，有顶栏，参考设置页的顶栏样式
页面中内容宽度为 500px 比较合适，这样pc与移动端的布局是一样的

页面中有，在线用户列表、全部用户列表
在线用户列表暂不需要分页
全部用户列表有搜索栏、分页栏，分页栏参考图片页的分页栏

点击用户行后，打开用户详情对话框

最终完成后，可以在大屏时将 在线用户、全部用户 显示在主页聊天的左侧
```
![](assets/Pasted%20image%2020251210133212.png)

在线用户功能实现思路
```
在pb后端创建 在线状态 集合
在前端中，已登录的用户每5分钟在 在线状态集合创建一条记录

获取在线用户：
前端启动后，订阅在线状态集合
- 官网文档 https://pocketbase.io/docs/api-realtime/
- 聊天消息的订阅参考，订阅的记录会保存在stroe中（不必持久化）
  - src\stores\realtime-messages.ts
  - src\composables\realtime-messages.ts
前端启动后，会查询一次 在线状态集合中10分钟内的全部记录，也保存在store中
根据store中的内容进行判断，距当前10分钟内有记录的用户即为在线
```


### 用户@功能、语音消息
计划中